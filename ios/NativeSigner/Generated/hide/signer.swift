// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(signerFFI)
    import signerFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_signer_36d5_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_signer_36d5_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Serializable` can be read and written in a bytebuffer.
private protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
private protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol Primitive {}

private extension Primitive {
    typealias FfiType = Self

    static func lift(_ v: Self) throws -> Self {
        return v
    }

    func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
private protocol ViaFfiUsingByteBuffer: Serializable {}

private extension ViaFfiUsingByteBuffer {
    typealias FfiType = RustBuffer

    static func lift(_ buf: FfiType) throws -> Self {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    func lower() -> FfiType {
        let writer = Writer()
        write(into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Protocols for converters we'll implement in templates

private protocol FfiConverter {
    associatedtype SwiftType
    associatedtype FfiType

    static func lift(_ ffiValue: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType

    static func read(from: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into: Writer)
}

private protocol FfiConverterUsingByteBuffer: FfiConverter where FfiType == RustBuffer {
    // Empty, because we want to declare some helper methods in the extension below.
}

extension FfiConverterUsingByteBuffer {
    static func lower(_ value: SwiftType) -> FfiType {
        let writer = Writer()
        Self.write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }

    static func lift(_ buf: FfiType) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }
}

// Helpers for structural types. Note that because of canonical_names, it /should/ be impossible
// to make another `FfiConverterSequence` etc just using the UDL.
private enum FfiConverterSequence {
    static func write<T>(_ value: [T], into buf: Writer, writeItem: (T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            writeItem(item, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> [T] {
        let len: Int32 = try buf.readInt()
        var seq = [T]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try readItem(buf))
        }
        return seq
    }
}

private enum FfiConverterOptional {
    static func write<T>(_ value: T?, into buf: Writer, writeItem: (T, Writer) -> Void) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        writeItem(value, buf)
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> T? {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try readItem(buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private enum FfiConverterDictionary {
    static func write<T>(_ value: [String: T], into buf: Writer, writeItem: (String, T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            writeItem(key, value, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> (String, T)) throws -> [String: T] {
        let len: Int32 = try buf.readInt()
        var dict = [String: T]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let (key, value) = try readItem(buf)
            dict[key] = value
        }
        return dict
    }
}

// Public interface members begin here.

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerifierValue {
    case standard(m: String)
}

extension VerifierValue: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> VerifierValue {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .standard(
                m: try FfiConverterTypeMultiSigner.read(buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .standard(m):
            buf.writeInt(Int32(1))
            FfiConverterTypeMultiSigner.write(m, buf)
        }
    }
}

extension VerifierValue: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Encryption {
    case ed25519
    case sr25519
    case ecdsa
}

extension Encryption: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Encryption {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .ed25519
        case 2: return .sr25519
        case 3: return .ecdsa
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .ed25519:
            buf.writeInt(Int32(1))

        case .sr25519:
            buf.writeInt(Int32(2))

        case .ecdsa:
            buf.writeInt(Int32(3))
        }
    }
}

extension Encryption: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ValidCurrentVerifier {
    case general
    case custom(v: Verifier)
}

extension ValidCurrentVerifier: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ValidCurrentVerifier {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .general
        case 2: return .custom(
                v: try Verifier.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .general:
            buf.writeInt(Int32(1))

        case let .custom(v):
            buf.writeInt(Int32(2))
            v.write(into: buf)
        }
    }
}

extension ValidCurrentVerifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Event {
    case metadataAdded(metaValuesDisplay: MetaValuesDisplay)
    case metadataRemoved(metaValuesDisplay: MetaValuesDisplay)
    case metadataSigned(metaValuesExport: MetaValuesExport)
    case networkSpecsAdded(networkSpecsDisplay: NetworkSpecsDisplay)
    case networkSpecsRemoved(networkSpecsDisplay: NetworkSpecsDisplay)
    case networkSpecsSigned(networkSpecsExport: NetworkSpecsExport)
    case networkVerifierSet(networkVerifierDisplay: NetworkVerifierDisplay)
    case generalVerifierSet(verifier: Verifier)
    case typesAdded(typesDisplay: TypesDisplay)
    case typesRemoved(typesDisplay: TypesDisplay)
    case typesSigned(typesExport: TypesExport)
    case transactionSigned(signDisplay: SignDisplay)
    case transactionSignError(signDisplay: SignDisplay)
    case messageSigned(signMessageDisplay: SignMessageDisplay)
    case messageSignError(signMessageDisplay: SignMessageDisplay)
    case identityAdded(identityHistory: IdentityHistory)
    case identityRemoved(identityHistory: IdentityHistory)
    case identitiesWiped
    case deviceWasOnline
    case resetDangerRecord
    case seedCreated(seedCreated: String)
    case seedNameWasShown(seedNameWasShown: String)
    case warning(warning: String)
    case wrongPassword
    case userEntry(userEntry: String)
    case systemEntry(systemEntry: String)
    case historyCleared
    case databaseInitiated
}

extension Event: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Event {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .metadataAdded(
                metaValuesDisplay: try MetaValuesDisplay.read(from: buf)
            )
        case 2: return .metadataRemoved(
                metaValuesDisplay: try MetaValuesDisplay.read(from: buf)
            )
        case 3: return .metadataSigned(
                metaValuesExport: try MetaValuesExport.read(from: buf)
            )
        case 4: return .networkSpecsAdded(
                networkSpecsDisplay: try NetworkSpecsDisplay.read(from: buf)
            )
        case 5: return .networkSpecsRemoved(
                networkSpecsDisplay: try NetworkSpecsDisplay.read(from: buf)
            )
        case 6: return .networkSpecsSigned(
                networkSpecsExport: try NetworkSpecsExport.read(from: buf)
            )
        case 7: return .networkVerifierSet(
                networkVerifierDisplay: try NetworkVerifierDisplay.read(from: buf)
            )
        case 8: return .generalVerifierSet(
                verifier: try Verifier.read(from: buf)
            )
        case 9: return .typesAdded(
                typesDisplay: try TypesDisplay.read(from: buf)
            )
        case 10: return .typesRemoved(
                typesDisplay: try TypesDisplay.read(from: buf)
            )
        case 11: return .typesSigned(
                typesExport: try TypesExport.read(from: buf)
            )
        case 12: return .transactionSigned(
                signDisplay: try SignDisplay.read(from: buf)
            )
        case 13: return .transactionSignError(
                signDisplay: try SignDisplay.read(from: buf)
            )
        case 14: return .messageSigned(
                signMessageDisplay: try SignMessageDisplay.read(from: buf)
            )
        case 15: return .messageSignError(
                signMessageDisplay: try SignMessageDisplay.read(from: buf)
            )
        case 16: return .identityAdded(
                identityHistory: try IdentityHistory.read(from: buf)
            )
        case 17: return .identityRemoved(
                identityHistory: try IdentityHistory.read(from: buf)
            )
        case 18: return .identitiesWiped
        case 19: return .deviceWasOnline
        case 20: return .resetDangerRecord
        case 21: return .seedCreated(
                seedCreated: try String.read(from: buf)
            )
        case 22: return .seedNameWasShown(
                seedNameWasShown: try String.read(from: buf)
            )
        case 23: return .warning(
                warning: try String.read(from: buf)
            )
        case 24: return .wrongPassword
        case 25: return .userEntry(
                userEntry: try String.read(from: buf)
            )
        case 26: return .systemEntry(
                systemEntry: try String.read(from: buf)
            )
        case 27: return .historyCleared
        case 28: return .databaseInitiated
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .metadataAdded(metaValuesDisplay):
            buf.writeInt(Int32(1))
            metaValuesDisplay.write(into: buf)

        case let .metadataRemoved(metaValuesDisplay):
            buf.writeInt(Int32(2))
            metaValuesDisplay.write(into: buf)

        case let .metadataSigned(metaValuesExport):
            buf.writeInt(Int32(3))
            metaValuesExport.write(into: buf)

        case let .networkSpecsAdded(networkSpecsDisplay):
            buf.writeInt(Int32(4))
            networkSpecsDisplay.write(into: buf)

        case let .networkSpecsRemoved(networkSpecsDisplay):
            buf.writeInt(Int32(5))
            networkSpecsDisplay.write(into: buf)

        case let .networkSpecsSigned(networkSpecsExport):
            buf.writeInt(Int32(6))
            networkSpecsExport.write(into: buf)

        case let .networkVerifierSet(networkVerifierDisplay):
            buf.writeInt(Int32(7))
            networkVerifierDisplay.write(into: buf)

        case let .generalVerifierSet(verifier):
            buf.writeInt(Int32(8))
            verifier.write(into: buf)

        case let .typesAdded(typesDisplay):
            buf.writeInt(Int32(9))
            typesDisplay.write(into: buf)

        case let .typesRemoved(typesDisplay):
            buf.writeInt(Int32(10))
            typesDisplay.write(into: buf)

        case let .typesSigned(typesExport):
            buf.writeInt(Int32(11))
            typesExport.write(into: buf)

        case let .transactionSigned(signDisplay):
            buf.writeInt(Int32(12))
            signDisplay.write(into: buf)

        case let .transactionSignError(signDisplay):
            buf.writeInt(Int32(13))
            signDisplay.write(into: buf)

        case let .messageSigned(signMessageDisplay):
            buf.writeInt(Int32(14))
            signMessageDisplay.write(into: buf)

        case let .messageSignError(signMessageDisplay):
            buf.writeInt(Int32(15))
            signMessageDisplay.write(into: buf)

        case let .identityAdded(identityHistory):
            buf.writeInt(Int32(16))
            identityHistory.write(into: buf)

        case let .identityRemoved(identityHistory):
            buf.writeInt(Int32(17))
            identityHistory.write(into: buf)

        case .identitiesWiped:
            buf.writeInt(Int32(18))

        case .deviceWasOnline:
            buf.writeInt(Int32(19))

        case .resetDangerRecord:
            buf.writeInt(Int32(20))

        case let .seedCreated(seedCreated):
            buf.writeInt(Int32(21))
            seedCreated.write(into: buf)

        case let .seedNameWasShown(seedNameWasShown):
            buf.writeInt(Int32(22))
            seedNameWasShown.write(into: buf)

        case let .warning(warning):
            buf.writeInt(Int32(23))
            warning.write(into: buf)

        case .wrongPassword:
            buf.writeInt(Int32(24))

        case let .userEntry(userEntry):
            buf.writeInt(Int32(25))
            userEntry.write(into: buf)

        case let .systemEntry(systemEntry):
            buf.writeInt(Int32(26))
            systemEntry.write(into: buf)

        case .historyCleared:
            buf.writeInt(Int32(27))

        case .databaseInitiated:
            buf.writeInt(Int32(28))
        }
    }
}

extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Action {
    case start
    case navbarLog
    case navbarScan
    case navbarKeys
    case navbarSettings
    case goBack
    case goForward
    case selectSeed
    case selectKey
    case newKey
    case rightButton
    case shield
    case newSeed
    case recoverSeed
    case backupSeed
    case networkSelector
    case nextUnit
    case previousUnit
    case changeNetwork
    case checkPassword
    case transactionFetched
    case removeNetwork
    case removeMetadata
    case removeTypes
    case signNetworkSpecs
    case signMetadata
    case signTypes
    case manageNetworks
    case viewGeneralVerifier
    case manageMetadata
    case removeKey
    case removeSeed
    case clearLog
    case createLogComment
    case showLogDetails
    case swipe
    case longTap
    case selectAll
    case exportMultiSelect
    case increment
    case showDocuments
    case textEntry
    case pushWord
    case nothing
}

extension Action: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Action {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .start
        case 2: return .navbarLog
        case 3: return .navbarScan
        case 4: return .navbarKeys
        case 5: return .navbarSettings
        case 6: return .goBack
        case 7: return .goForward
        case 8: return .selectSeed
        case 9: return .selectKey
        case 10: return .newKey
        case 11: return .rightButton
        case 12: return .shield
        case 13: return .newSeed
        case 14: return .recoverSeed
        case 15: return .backupSeed
        case 16: return .networkSelector
        case 17: return .nextUnit
        case 18: return .previousUnit
        case 19: return .changeNetwork
        case 20: return .checkPassword
        case 21: return .transactionFetched
        case 22: return .removeNetwork
        case 23: return .removeMetadata
        case 24: return .removeTypes
        case 25: return .signNetworkSpecs
        case 26: return .signMetadata
        case 27: return .signTypes
        case 28: return .manageNetworks
        case 29: return .viewGeneralVerifier
        case 30: return .manageMetadata
        case 31: return .removeKey
        case 32: return .removeSeed
        case 33: return .clearLog
        case 34: return .createLogComment
        case 35: return .showLogDetails
        case 36: return .swipe
        case 37: return .longTap
        case 38: return .selectAll
        case 39: return .exportMultiSelect
        case 40: return .increment
        case 41: return .showDocuments
        case 42: return .textEntry
        case 43: return .pushWord
        case 44: return .nothing
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .start:
            buf.writeInt(Int32(1))

        case .navbarLog:
            buf.writeInt(Int32(2))

        case .navbarScan:
            buf.writeInt(Int32(3))

        case .navbarKeys:
            buf.writeInt(Int32(4))

        case .navbarSettings:
            buf.writeInt(Int32(5))

        case .goBack:
            buf.writeInt(Int32(6))

        case .goForward:
            buf.writeInt(Int32(7))

        case .selectSeed:
            buf.writeInt(Int32(8))

        case .selectKey:
            buf.writeInt(Int32(9))

        case .newKey:
            buf.writeInt(Int32(10))

        case .rightButton:
            buf.writeInt(Int32(11))

        case .shield:
            buf.writeInt(Int32(12))

        case .newSeed:
            buf.writeInt(Int32(13))

        case .recoverSeed:
            buf.writeInt(Int32(14))

        case .backupSeed:
            buf.writeInt(Int32(15))

        case .networkSelector:
            buf.writeInt(Int32(16))

        case .nextUnit:
            buf.writeInt(Int32(17))

        case .previousUnit:
            buf.writeInt(Int32(18))

        case .changeNetwork:
            buf.writeInt(Int32(19))

        case .checkPassword:
            buf.writeInt(Int32(20))

        case .transactionFetched:
            buf.writeInt(Int32(21))

        case .removeNetwork:
            buf.writeInt(Int32(22))

        case .removeMetadata:
            buf.writeInt(Int32(23))

        case .removeTypes:
            buf.writeInt(Int32(24))

        case .signNetworkSpecs:
            buf.writeInt(Int32(25))

        case .signMetadata:
            buf.writeInt(Int32(26))

        case .signTypes:
            buf.writeInt(Int32(27))

        case .manageNetworks:
            buf.writeInt(Int32(28))

        case .viewGeneralVerifier:
            buf.writeInt(Int32(29))

        case .manageMetadata:
            buf.writeInt(Int32(30))

        case .removeKey:
            buf.writeInt(Int32(31))

        case .removeSeed:
            buf.writeInt(Int32(32))

        case .clearLog:
            buf.writeInt(Int32(33))

        case .createLogComment:
            buf.writeInt(Int32(34))

        case .showLogDetails:
            buf.writeInt(Int32(35))

        case .swipe:
            buf.writeInt(Int32(36))

        case .longTap:
            buf.writeInt(Int32(37))

        case .selectAll:
            buf.writeInt(Int32(38))

        case .exportMultiSelect:
            buf.writeInt(Int32(39))

        case .increment:
            buf.writeInt(Int32(40))

        case .showDocuments:
            buf.writeInt(Int32(41))

        case .textEntry:
            buf.writeInt(Int32(42))

        case .pushWord:
            buf.writeInt(Int32(43))

        case .nothing:
            buf.writeInt(Int32(44))
        }
    }
}

extension Action: Equatable, Hashable {}

public func actionGetName(action: Action) -> String {
    let _retval = try!

        rustCall {
            signer_36d5_action_get_name(action.lower(), $0)
        }
    return try! String.lift(_retval)
}

public func initNavigation(dbname: String, seedNames: String) {
    try!

        rustCall {
            signer_36d5_init_navigation(dbname.lower(), seedNames.lower(), $0)
        }
}

public func backendAction(action: Action, details: String, seedPhrase: String) -> String {
    let _retval = try!

        rustCall {
            signer_36d5_backend_action(action.lower(), details.lower(), seedPhrase.lower(), $0)
        }
    return try! String.lift(_retval)
}

public func updateSeedNames(seedNames: String) {
    try!

        rustCall {
            signer_36d5_update_seed_names(seedNames.lower(), $0)
        }
}

public func qrparserGetPacketsTotal(data: String, cleaned: Bool) throws -> UInt32 {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_qrparser_get_packets_total(data.lower(), cleaned.lower(), $0)
        }
    return try UInt32.lift(_retval)
}

public func qrparserTryDecodeQrSequence(data: String, cleaned: Bool) throws -> String {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_qrparser_try_decode_qr_sequence(data.lower(), cleaned.lower(), $0)
        }
    return try String.lift(_retval)
}

public func substratePathCheck(seedName: String, path: String, network: String, dbname: String) -> String {
    let _retval = try!

        rustCall {
            signer_36d5_substrate_path_check(seedName.lower(), path.lower(), network.lower(), dbname.lower(), $0)
        }
    return try! String.lift(_retval)
}

public func historyInitHistoryWithCert(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_init_history_with_cert(dbname.lower(), $0)
        }
}

public func historyInitHistoryNoCert(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_init_history_no_cert(dbname.lower(), $0)
        }
}

public func historyDeviceWasOnline(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_device_was_online(dbname.lower(), $0)
        }
}

public func historyGetWarnings(dbname: String) throws -> Bool {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_get_warnings(dbname.lower(), $0)
        }
    return try Bool.lift(_retval)
}

public func historyAcknowledgeWarnings(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_acknowledge_warnings(dbname.lower(), $0)
        }
}

public func historyEntrySystem(event: Event, dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_entry_system(event.lower(), dbname.lower(), $0)
        }
}

public func historySeedNameWasShown(seedName: String, dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_36d5_history_seed_name_was_shown(seedName.lower(), dbname.lower(), $0)
        }
}

public func getAllTxCards() -> String {
    let _retval = try!

        rustCall {
            signer_36d5_get_all_tx_cards($0)
        }
    return try! String.lift(_retval)
}

public func getAllLogCards() -> String {
    let _retval = try!

        rustCall {
            signer_36d5_get_all_log_cards($0)
        }
    return try! String.lift(_retval)
}

public struct MetaValuesDisplay {
    public var name: String
    public var version: UInt32
    public var metaHash: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt32, metaHash: [UInt8]) {
        self.name = name
        self.version = version
        self.metaHash = metaHash
    }
}

extension MetaValuesDisplay: Equatable, Hashable {
    public static func == (lhs: MetaValuesDisplay, rhs: MetaValuesDisplay) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(metaHash)
    }
}

private extension MetaValuesDisplay {
    static func read(from buf: Reader) throws -> MetaValuesDisplay {
        return try MetaValuesDisplay(
            name: String.read(from: buf),
            version: UInt32.read(from: buf),
            metaHash: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        FfiConverterSequenceUInt8.write(metaHash, into: buf)
    }
}

extension MetaValuesDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Verifier {
    public var v: VerifierValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(v: VerifierValue?) {
        self.v = v
    }
}

extension Verifier: Equatable, Hashable {
    public static func == (lhs: Verifier, rhs: Verifier) -> Bool {
        if lhs.v != rhs.v {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(v)
    }
}

private extension Verifier {
    static func read(from buf: Reader) throws -> Verifier {
        return try Verifier(
            v: FfiConverterOptionEnumVerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionEnumVerifierValue.write(v, into: buf)
    }
}

extension Verifier: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecs {
    public var base58prefix: UInt16
    public var color: String
    public var decimals: UInt8
    public var encryption: Encryption
    public var genesisHash: [UInt8]
    public var logo: String
    public var name: String
    public var order: UInt8
    public var pathId: String
    public var secondaryColor: String
    public var title: String
    public var unit: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58prefix: UInt16, color: String, decimals: UInt8, encryption: Encryption, genesisHash: [UInt8], logo: String, name: String, order: UInt8, pathId: String, secondaryColor: String, title: String, unit: String) {
        self.base58prefix = base58prefix
        self.color = color
        self.decimals = decimals
        self.encryption = encryption
        self.genesisHash = genesisHash
        self.logo = logo
        self.name = name
        self.order = order
        self.pathId = pathId
        self.secondaryColor = secondaryColor
        self.title = title
        self.unit = unit
    }
}

extension NetworkSpecs: Equatable, Hashable {
    public static func == (lhs: NetworkSpecs, rhs: NetworkSpecs) -> Bool {
        if lhs.base58prefix != rhs.base58prefix {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.pathId != rhs.pathId {
            return false
        }
        if lhs.secondaryColor != rhs.secondaryColor {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58prefix)
        hasher.combine(color)
        hasher.combine(decimals)
        hasher.combine(encryption)
        hasher.combine(genesisHash)
        hasher.combine(logo)
        hasher.combine(name)
        hasher.combine(order)
        hasher.combine(pathId)
        hasher.combine(secondaryColor)
        hasher.combine(title)
        hasher.combine(unit)
    }
}

private extension NetworkSpecs {
    static func read(from buf: Reader) throws -> NetworkSpecs {
        return try NetworkSpecs(
            base58prefix: UInt16.read(from: buf),
            color: String.read(from: buf),
            decimals: UInt8.read(from: buf),
            encryption: Encryption.read(from: buf),
            genesisHash: FfiConverterTypeH256.read(buf),
            logo: String.read(from: buf),
            name: String.read(from: buf),
            order: UInt8.read(from: buf),
            pathId: String.read(from: buf),
            secondaryColor: String.read(from: buf),
            title: String.read(from: buf),
            unit: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58prefix.write(into: buf)
        color.write(into: buf)
        decimals.write(into: buf)
        encryption.write(into: buf)
        FfiConverterTypeH256.write(genesisHash, buf)
        logo.write(into: buf)
        name.write(into: buf)
        order.write(into: buf)
        pathId.write(into: buf)
        secondaryColor.write(into: buf)
        title.write(into: buf)
        unit.write(into: buf)
    }
}

extension NetworkSpecs: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsToSend {
    public var base58prefix: UInt16
    public var color: String
    public var decimals: UInt8
    public var encryption: Encryption
    public var genesisHash: [UInt8]
    public var logo: String
    public var name: String
    public var pathId: String
    public var secondaryColor: String
    public var title: String
    public var unit: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58prefix: UInt16, color: String, decimals: UInt8, encryption: Encryption, genesisHash: [UInt8], logo: String, name: String, pathId: String, secondaryColor: String, title: String, unit: String) {
        self.base58prefix = base58prefix
        self.color = color
        self.decimals = decimals
        self.encryption = encryption
        self.genesisHash = genesisHash
        self.logo = logo
        self.name = name
        self.pathId = pathId
        self.secondaryColor = secondaryColor
        self.title = title
        self.unit = unit
    }
}

extension NetworkSpecsToSend: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsToSend, rhs: NetworkSpecsToSend) -> Bool {
        if lhs.base58prefix != rhs.base58prefix {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pathId != rhs.pathId {
            return false
        }
        if lhs.secondaryColor != rhs.secondaryColor {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58prefix)
        hasher.combine(color)
        hasher.combine(decimals)
        hasher.combine(encryption)
        hasher.combine(genesisHash)
        hasher.combine(logo)
        hasher.combine(name)
        hasher.combine(pathId)
        hasher.combine(secondaryColor)
        hasher.combine(title)
        hasher.combine(unit)
    }
}

private extension NetworkSpecsToSend {
    static func read(from buf: Reader) throws -> NetworkSpecsToSend {
        return try NetworkSpecsToSend(
            base58prefix: UInt16.read(from: buf),
            color: String.read(from: buf),
            decimals: UInt8.read(from: buf),
            encryption: Encryption.read(from: buf),
            genesisHash: FfiConverterTypeH256.read(buf),
            logo: String.read(from: buf),
            name: String.read(from: buf),
            pathId: String.read(from: buf),
            secondaryColor: String.read(from: buf),
            title: String.read(from: buf),
            unit: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58prefix.write(into: buf)
        color.write(into: buf)
        decimals.write(into: buf)
        encryption.write(into: buf)
        FfiConverterTypeH256.write(genesisHash, buf)
        logo.write(into: buf)
        name.write(into: buf)
        pathId.write(into: buf)
        secondaryColor.write(into: buf)
        title.write(into: buf)
        unit.write(into: buf)
    }
}

extension NetworkSpecsToSend: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsDisplay {
    public var specs: NetworkSpecs
    public var validCurrentVerifier: ValidCurrentVerifier
    public var generalVerifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specs: NetworkSpecs, validCurrentVerifier: ValidCurrentVerifier, generalVerifier: Verifier) {
        self.specs = specs
        self.validCurrentVerifier = validCurrentVerifier
        self.generalVerifier = generalVerifier
    }
}

extension NetworkSpecsDisplay: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsDisplay, rhs: NetworkSpecsDisplay) -> Bool {
        if lhs.specs != rhs.specs {
            return false
        }
        if lhs.validCurrentVerifier != rhs.validCurrentVerifier {
            return false
        }
        if lhs.generalVerifier != rhs.generalVerifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specs)
        hasher.combine(validCurrentVerifier)
        hasher.combine(generalVerifier)
    }
}

private extension NetworkSpecsDisplay {
    static func read(from buf: Reader) throws -> NetworkSpecsDisplay {
        return try NetworkSpecsDisplay(
            specs: NetworkSpecs.read(from: buf),
            validCurrentVerifier: ValidCurrentVerifier.read(from: buf),
            generalVerifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specs.write(into: buf)
        validCurrentVerifier.write(into: buf)
        generalVerifier.write(into: buf)
    }
}

extension NetworkSpecsDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsExport {
    public var specsToSend: NetworkSpecsToSend
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specsToSend: NetworkSpecsToSend, signedBy: VerifierValue) {
        self.specsToSend = specsToSend
        self.signedBy = signedBy
    }
}

extension NetworkSpecsExport: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsExport, rhs: NetworkSpecsExport) -> Bool {
        if lhs.specsToSend != rhs.specsToSend {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specsToSend)
        hasher.combine(signedBy)
    }
}

private extension NetworkSpecsExport {
    static func read(from buf: Reader) throws -> NetworkSpecsExport {
        return try NetworkSpecsExport(
            specsToSend: NetworkSpecsToSend.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specsToSend.write(into: buf)
        signedBy.write(into: buf)
    }
}

extension NetworkSpecsExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkVerifierDisplay {
    public var genesisHash: [UInt8]
    public var validCurrentVerifier: ValidCurrentVerifier
    public var generalVerifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(genesisHash: [UInt8], validCurrentVerifier: ValidCurrentVerifier, generalVerifier: Verifier) {
        self.genesisHash = genesisHash
        self.validCurrentVerifier = validCurrentVerifier
        self.generalVerifier = generalVerifier
    }
}

extension NetworkVerifierDisplay: Equatable, Hashable {
    public static func == (lhs: NetworkVerifierDisplay, rhs: NetworkVerifierDisplay) -> Bool {
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.validCurrentVerifier != rhs.validCurrentVerifier {
            return false
        }
        if lhs.generalVerifier != rhs.generalVerifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(genesisHash)
        hasher.combine(validCurrentVerifier)
        hasher.combine(generalVerifier)
    }
}

private extension NetworkVerifierDisplay {
    static func read(from buf: Reader) throws -> NetworkVerifierDisplay {
        return try NetworkVerifierDisplay(
            genesisHash: FfiConverterSequenceUInt8.read(from: buf),
            validCurrentVerifier: ValidCurrentVerifier.read(from: buf),
            generalVerifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(genesisHash, into: buf)
        validCurrentVerifier.write(into: buf)
        generalVerifier.write(into: buf)
    }
}

extension NetworkVerifierDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TypesDisplay {
    public var typesHash: [UInt8]
    public var verifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typesHash: [UInt8], verifier: Verifier) {
        self.typesHash = typesHash
        self.verifier = verifier
    }
}

extension TypesDisplay: Equatable, Hashable {
    public static func == (lhs: TypesDisplay, rhs: TypesDisplay) -> Bool {
        if lhs.typesHash != rhs.typesHash {
            return false
        }
        if lhs.verifier != rhs.verifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typesHash)
        hasher.combine(verifier)
    }
}

private extension TypesDisplay {
    static func read(from buf: Reader) throws -> TypesDisplay {
        return try TypesDisplay(
            typesHash: FfiConverterSequenceUInt8.read(from: buf),
            verifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(typesHash, into: buf)
        verifier.write(into: buf)
    }
}

extension TypesDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TypesExport {
    public var typesHash: [UInt8]
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typesHash: [UInt8], signedBy: VerifierValue) {
        self.typesHash = typesHash
        self.signedBy = signedBy
    }
}

extension TypesExport: Equatable, Hashable {
    public static func == (lhs: TypesExport, rhs: TypesExport) -> Bool {
        if lhs.typesHash != rhs.typesHash {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typesHash)
        hasher.combine(signedBy)
    }
}

private extension TypesExport {
    static func read(from buf: Reader) throws -> TypesExport {
        return try TypesExport(
            typesHash: FfiConverterSequenceUInt8.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(typesHash, into: buf)
        signedBy.write(into: buf)
    }
}

extension TypesExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SignDisplay {
    public var transaction: [UInt8]
    public var networkName: String
    public var signedBy: VerifierValue
    public var userComment: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: [UInt8], networkName: String, signedBy: VerifierValue, userComment: String) {
        self.transaction = transaction
        self.networkName = networkName
        self.signedBy = signedBy
        self.userComment = userComment
    }
}

extension SignDisplay: Equatable, Hashable {
    public static func == (lhs: SignDisplay, rhs: SignDisplay) -> Bool {
        if lhs.transaction != rhs.transaction {
            return false
        }
        if lhs.networkName != rhs.networkName {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        if lhs.userComment != rhs.userComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transaction)
        hasher.combine(networkName)
        hasher.combine(signedBy)
        hasher.combine(userComment)
    }
}

private extension SignDisplay {
    static func read(from buf: Reader) throws -> SignDisplay {
        return try SignDisplay(
            transaction: FfiConverterSequenceUInt8.read(from: buf),
            networkName: String.read(from: buf),
            signedBy: VerifierValue.read(from: buf),
            userComment: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(transaction, into: buf)
        networkName.write(into: buf)
        signedBy.write(into: buf)
        userComment.write(into: buf)
    }
}

extension SignDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SignMessageDisplay {
    public var message: String
    public var networkName: String
    public var signedBy: VerifierValue
    public var userComment: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, networkName: String, signedBy: VerifierValue, userComment: String) {
        self.message = message
        self.networkName = networkName
        self.signedBy = signedBy
        self.userComment = userComment
    }
}

extension SignMessageDisplay: Equatable, Hashable {
    public static func == (lhs: SignMessageDisplay, rhs: SignMessageDisplay) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.networkName != rhs.networkName {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        if lhs.userComment != rhs.userComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(networkName)
        hasher.combine(signedBy)
        hasher.combine(userComment)
    }
}

private extension SignMessageDisplay {
    static func read(from buf: Reader) throws -> SignMessageDisplay {
        return try SignMessageDisplay(
            message: String.read(from: buf),
            networkName: String.read(from: buf),
            signedBy: VerifierValue.read(from: buf),
            userComment: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        message.write(into: buf)
        networkName.write(into: buf)
        signedBy.write(into: buf)
        userComment.write(into: buf)
    }
}

extension SignMessageDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct IdentityHistory {
    public var seedName: String
    public var encryption: Encryption
    public var publicKey: [UInt8]
    public var path: String
    public var networkGenesisHash: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, encryption: Encryption, publicKey: [UInt8], path: String, networkGenesisHash: [UInt8]) {
        self.seedName = seedName
        self.encryption = encryption
        self.publicKey = publicKey
        self.path = path
        self.networkGenesisHash = networkGenesisHash
    }
}

extension IdentityHistory: Equatable, Hashable {
    public static func == (lhs: IdentityHistory, rhs: IdentityHistory) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkGenesisHash != rhs.networkGenesisHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(encryption)
        hasher.combine(publicKey)
        hasher.combine(path)
        hasher.combine(networkGenesisHash)
    }
}

private extension IdentityHistory {
    static func read(from buf: Reader) throws -> IdentityHistory {
        return try IdentityHistory(
            seedName: String.read(from: buf),
            encryption: Encryption.read(from: buf),
            publicKey: FfiConverterSequenceUInt8.read(from: buf),
            path: String.read(from: buf),
            networkGenesisHash: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        encryption.write(into: buf)
        FfiConverterSequenceUInt8.write(publicKey, into: buf)
        path.write(into: buf)
        FfiConverterSequenceUInt8.write(networkGenesisHash, into: buf)
    }
}

extension IdentityHistory: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MetaValuesExport {
    public var name: String
    public var version: UInt32
    public var metaHash: [UInt8]
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt32, metaHash: [UInt8], signedBy: VerifierValue) {
        self.name = name
        self.version = version
        self.metaHash = metaHash
        self.signedBy = signedBy
    }
}

extension MetaValuesExport: Equatable, Hashable {
    public static func == (lhs: MetaValuesExport, rhs: MetaValuesExport) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(metaHash)
        hasher.combine(signedBy)
    }
}

private extension MetaValuesExport {
    static func read(from buf: Reader) throws -> MetaValuesExport {
        return try MetaValuesExport(
            name: String.read(from: buf),
            version: UInt32.read(from: buf),
            metaHash: FfiConverterSequenceUInt8.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        FfiConverterSequenceUInt8.write(metaHash, into: buf)
        signedBy.write(into: buf)
    }
}

extension MetaValuesExport: ViaFfiUsingByteBuffer, ViaFfi {}

public enum ErrorDisplayed {
    case Str(s: String)
}

extension ErrorDisplayed: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ErrorDisplayed {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .Str(
                s: try String.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .Str(s):
            buf.writeInt(Int32(1))
            s.write(into: buf)
        }
    }
}

extension ErrorDisplayed: Equatable, Hashable {}

extension ErrorDisplayed: Error {}
private enum FfiConverterTypeEcdsaPublic {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeEd25519Public {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeH256 {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeMultiSigner {
    fileprivate static func read(_ buf: Reader) throws -> String {
        return try String.read(from: buf)
    }

    fileprivate static func write(_ value: String, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> String {
        return try String.lift(value)
    }

    fileprivate static func lower(_ value: String) -> RustBuffer {
        return value.lower()
    }
}

private enum FfiConverterTypeSr25519Public {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

extension UInt8: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt16: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        return v != 0
    }

    fileprivate func lower() -> FfiType {
        return self ? 1 : 0
    }
}

extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            v.deallocate()
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(utf8.count)
        buf.writeInt(len)
        buf.writeBytes(utf8)
    }
}

// Helper code for IdentityHistory record is found in RecordTemplate.swift
// Helper code for MetaValuesDisplay record is found in RecordTemplate.swift
// Helper code for MetaValuesExport record is found in RecordTemplate.swift
// Helper code for NetworkSpecs record is found in RecordTemplate.swift
// Helper code for NetworkSpecsDisplay record is found in RecordTemplate.swift
// Helper code for NetworkSpecsExport record is found in RecordTemplate.swift
// Helper code for NetworkSpecsToSend record is found in RecordTemplate.swift
// Helper code for NetworkVerifierDisplay record is found in RecordTemplate.swift
// Helper code for SignDisplay record is found in RecordTemplate.swift
// Helper code for SignMessageDisplay record is found in RecordTemplate.swift
// Helper code for TypesDisplay record is found in RecordTemplate.swift
// Helper code for TypesExport record is found in RecordTemplate.swift
// Helper code for Verifier record is found in RecordTemplate.swift
// Helper code for Action enum is found in EnumTemplate.swift
// Helper code for Encryption enum is found in EnumTemplate.swift
// Helper code for Event enum is found in EnumTemplate.swift
// Helper code for ValidCurrentVerifier enum is found in EnumTemplate.swift
// Helper code for VerifierValue enum is found in EnumTemplate.swift
// Helper code for ErrorDisplayed error is found in ErrorTemplate.swift

private enum FfiConverterOptionEnumVerifierValue: FfiConverterUsingByteBuffer {
    typealias SwiftType = VerifierValue?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try VerifierValue.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceUInt8: FfiConverterUsingByteBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try UInt8.read(from: buf)
        }
    }
}

// Helper code for EcdsaPublic is found in CustomType.py
// Helper code for Ed25519Public is found in CustomType.py
// Helper code for H256 is found in CustomType.py
// Helper code for MultiSigner is found in CustomType.py
// Helper code for Sr25519Public is found in CustomType.py

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum SignerLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
        // No initialization code needed
    }
}
